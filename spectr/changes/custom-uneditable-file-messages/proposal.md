# Proposal: Custom Messages for Uneditable Files

## Why

Currently, when Claude tries to write or update a file matching an `uneditableFiles` pattern, it receives a generic error message. Users have no way to provide context-specific guidance (e.g., "This file is auto-generated" or "Configuration changes require PR approval"). Adding custom messages makes the guardrail policy more informative and improves the developer experience by explaining *why* a file is protected.

## Problem

The `uneditableFiles` configuration is a simple array of glob patterns:
```yaml
rules:
  uneditableFiles:
    - "*.lock"
    - ".env"
    - "package.json"
```

When a file matches a pattern, conclaude blocks the operation with a generic message:
```
Blocked Write operation: file matches uneditable pattern '*.lock'. File: package-lock.json
```

This message doesn't explain *why* the file is protected, forcing users to read configuration files or documentation to understand the policy. For projects with multiple protection policies, this leads to poor user experience.

## Context

The existing `ToolUsageRule` type demonstrates a successful pattern for optional custom messages:
```rust
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ToolUsageRule {
    pub tool: String,
    pub pattern: String,
    pub action: String,
    pub message: Option<String>,  // <-- Custom message support
    pub command_pattern: Option<String>,
    pub match_mode: Option<String>,
}
```

The same pattern can be applied to uneditable file rules, enabling configurations like:

```yaml
rules:
  uneditableFiles:
    - pattern: "*.lock"
      message: "Lock files are auto-generated. Run 'npm install' to update."
    - pattern: ".env"
      message: "Environment files contain secrets and must not be committed."
    - "package.json"  # Backward compatible: still supports plain strings
```

## Proposed Solution

Transform `uneditableFiles` from `Vec<String>` to `Vec<UnEditableFileRule>` where each rule can optionally specify a custom message. The change is backward compatible: users can still provide simple string patterns.

### Type Transformation

**Before:**
```rust
pub struct RulesConfig {
    pub uneditable_files: Vec<String>,
}
```

**After:**
```rust
pub struct UnEditableFileRule {
    pub pattern: String,
    #[serde(default)]
    pub message: Option<String>,
}

pub struct RulesConfig {
    pub uneditable_files: Vec<UnEditableFileRule>,
}
```

### Configuration Examples

**Simple patterns (backward compatible):**
```yaml
rules:
  uneditableFiles:
    - "*.lock"
    - ".env"
```

Will be deserialized as:
```rust
vec![
    UnEditableFileRule { pattern: "*.lock".to_string(), message: None },
    UnEditableFileRule { pattern: ".env".to_string(), message: None },
]
```

**With custom messages:**
```yaml
rules:
  uneditableFiles:
    - pattern: "*.lock"
      message: "Lock files are auto-generated. Run 'npm install' to update."
    - pattern: ".env"
      message: "Environment files contain secrets. Use .env.example instead."
```

**Mixed (both formats in same list):**
```yaml
rules:
  uneditableFiles:
    - "*.lock"
    - pattern: ".env"
      message: "Secrets must not be committed."
```

## Impact

- **Configuration changes**: New optional `UnEditableFileRule` type with backward compatibility
- **Code changes**: Update `hooks.rs` to extract and use custom message when available
- **Schema changes**: Update JSON schema to reflect new rule structure
- **Documentation**: Add examples of custom message configurations
- **Breaking changes**: None - existing string arrays remain valid

## Files Affected

- `src/config.rs` - Add `UnEditableFileRule` type, update deserialization
- `src/hooks.rs` - Use custom message in blocked operation error
- `src/schema.rs` - Update example configuration
- `conclaude-schema.json` - Regenerated by tooling
- Documentation (examples, README)

## Dependencies

- No external dependencies required
- Builds on existing serde patterns used in `ToolUsageRule`

## Alternatives Considered

1. **Add message to existing patterns as tuple (pattern, message)** - Rejected: Serde can't easily handle mixed tuple/string arrays. Would require custom deserialization and break existing configs.

2. **Create separate messageMap config** - Rejected: Makes configuration harder to understand and maintain. Patterns and messages become separated.

3. **Only support object format, no strings** - Rejected: Breaks backward compatibility with existing configs.

4. **Always require message field** - Rejected: Generic error message is fine for many use cases. Optional message is more flexible.

## Success Criteria

- [ ] `UnEditableFileRule` type defined with pattern and optional message
- [ ] `RulesConfig.uneditable_files` updated to use new type
- [ ] Backward compatibility verified: string patterns still work
- [ ] Custom messages displayed when provided, generic message when empty
- [ ] Schema updated and validates correctly
- [ ] All tests pass
- [ ] Example configurations documented
- [ ] `openspec validate --strict` passes

## Timeline

This is a well-scoped enhancement with minimal risk:
- Type system changes: Simple struct addition
- Deserialization: Leverages existing serde patterns
- Message usage: Single-point change in error handling
- Testing: Straightforward test cases

## Open Questions / Clarifications

1. **Message length**: Should there be a maximum length for custom messages? (Suggest: no limit, let users decide)
2. **Newlines**: Should messages support multi-line text? (Suggest: yes, via YAML literals)
3. **Template variables**: Should messages support substitution (e.g., `{file_path}`)? (Suggest: defer to future, keep v1 simple)
4. **Configuration migration**: Should tooling help migrate existing configs? (Suggest: not needed, backward compatible)
