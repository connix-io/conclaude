# yaml-language-server: $schema=https://github.com/connix-io/conclaude/releases/latest/download/conclaude-schema.json
# Conclaude YAML Configuration - Complete Default Configuration
# This configuration defines how conclaude handles Claude Code hook events
# All supported options are shown below with their default values

# Stop hook configuration - runs when Claude is about to stop
stop:
  # Structured command format with optional custom error messages
  # Each command can have its own error message, and control output display
  commands: []
  # Examples:
  # commands:
  #   - run: "echo 'Starting build...'"
  #     showStdout: true    # User/Claude sees: "Starting build..."
  #
  #   - run: "npm test"
  #     showStdout: true    # Show test results to user/Claude
  #     showStderr: true    # Show test errors to user/Claude
  #     message: "Tests failed - please fix failing tests before continuing"
  #     maxOutputLines: 100 # Limit output to last 100 lines (1-10000)
  #
  #   - run: "npm run build"
  #     showStderr: true    # Only show build errors to user/Claude, hide stdout
  #     message: "Build failed - please fix compilation errors"
  #     maxOutputLines: 50  # Limit build output to last 50 lines

  # Infinite mode - allows Claude to continue automatically
  # When enabled, Claude receives the infiniteMessage to continue working
  # instead of ending the session after stop hook commands succeed
  infinite: false

  # Message to send when infinite mode is enabled
  infiniteMessage: "continue working on the task"

  # Alternative to infinite mode - run for a specific number of rounds
  # When set, Claude will continue for the specified number of rounds
  rounds: null
  # Example: rounds: 3

  # Prompt-prefix-based stop blocking configuration
  # When configured, allows blocking the Stop hook based on patterns matching
  # the first 100 characters of the initial prompt in a session.
  # This is useful for signaling extended work sessions via keywords like "ULTRATHINK".
  #
  # promptPrefixBlocking:
  #   # Glob patterns to match against the first 100 characters of the initial prompt
  #   # Matching is case-sensitive and uses glob syntax
  #   prefixes:
  #     - "ULTRATHINK*"           # Matches "ULTRATHINK", "ULTRATHINK help me", etc.
  #     - "*DEEP_WORK*"           # Matches anywhere in first 100 chars
  #
  #   # Messages to send when blocking the Stop hook
  #   # Each message can specify how many times it should be sent before advancing
  #   messages:
  #     - text: "Keep working on the task. Focus on quality and completeness."
  #       times: 3                # Send this message 3 times before moving to next
  #     - text: "Continue with the implementation. Document your decisions."
  #       times: 2                # Send this message 2 times
  #     - text: "Final push - ensure tests pass and code is clean."
  #                               # times defaults to 1 if not specified
  #
  # How it works:
  # 1. On UserPromptSubmit, the first 100 chars of the prompt are stored in the database
  # 2. On Stop hook, if prefix patterns match, the current message is returned to block
  # 3. Each time Stop is blocked, times_remaining decrements for the current message
  # 4. When times_remaining hits 0, queue_position advances to the next message
  # 5. When all messages are exhausted, the Stop hook proceeds normally
  #
  # Note: Requires database.enabled: true for session state persistence
  promptPrefixBlocking:
    prefixes:
      - "/spectr:proposal"
    messages:
      - text: "Now, lets get into the specifics and answer remaining open questions using the AskUserQuestion tool."
        times: 1
      - text: "Now, lets get into even more of the specifics and answer remaining open questions using the AskUserQuestion tool."
        times: 1
      - text: "Do another pass through the dir and make sure all decisions are correctly documneted"
        times: 1

# Subagent stop hook configuration - runs when subagents are about to stop
# This hook allows configuring different commands for different subagent names
# using pattern matching. Commands run when a subagent finishes its work.
subagentStop:
  # Map of subagent name patterns to command configurations
  # Each key is a glob pattern that matches against the subagent name
  # Commands are executed in the order they appear when pattern matches
  commands: {}
  # Examples:
  # commands:
  #   # Exact match - only runs for subagent named "coder"
  #   coder:
  #     - run: "npm run lint"
  #       showStdout: true
  #       showStderr: true
  #       message: "Linting failed - please fix errors before continuing"
  #       maxOutputLines: 100
  #
  #   # Glob pattern - runs for any subagent name starting with "test"
  #   test*:
  #     - run: "npm test"
  #       showStdout: true
  #       showStderr: true
  #       message: "Tests failed - please fix failing tests"
  #
  #   # Wildcard - runs for ALL subagents
  #   "*":
  #     - run: "echo 'Subagent {subagent_name} completed'"
  #       showStdout: true
  #
  # Pattern matching rules:
  #   - Patterns are matched in the order they appear in the configuration
  #   - First matching pattern's commands are executed
  #   - Use "*" to match all subagents (put last as fallback)
  #   - Glob patterns support: *, ?, [abc], [a-z], {foo,bar}
  #
  # Command options (same as stop hook):
  #   - run: (required) Command to execute
  #   - showStdout: (optional) Show stdout to user/Claude (default: false)
  #   - showStderr: (optional) Show stderr to user/Claude (default: false)
  #   - message: (optional) Custom error message on non-zero exit
  #   - maxOutputLines: (optional) Limit output lines (1-10000)
  #
  # Environment variables available in commands:
  #   - CONCLAUDE_AGENT_ID             - The subagent's identifier
  #   - CONCLAUDE_AGENT_TRANSCRIPT_PATH - Path to subagent's transcript
  #   - CONCLAUDE_SESSION_ID           - Current session ID
  #   - CONCLAUDE_TRANSCRIPT_PATH      - Main transcript file path
  #   - CONCLAUDE_HOOK_EVENT           - Always "SubagentStop"
  #   - CONCLAUDE_CWD                  - Current working directory
  #
  # Example with environment variable:
  # commands:
  #   coder:
  #     - run: "echo 'Coder subagent ${CONCLAUDE_AGENT_ID} finished'"
  #       showStdout: true

# Pre-tool-use hook configuration - runs before tools are executed
# All file protection rules are consolidated in this section
preToolUse:
  # Prevent Claude from creating or modifying files at the repository root
  # Helps maintain clean project structure
  preventRootAdditions: true

  # Files that Claude cannot edit, using glob patterns
  # Supports various glob patterns for flexible file protection
  # By default, conclaude's own config files are protected to prevent the AI
  # from modifying guardrail settings - this is a security best practice
  #
  # Two formats are supported:
  # 1. Simple string patterns: "*.lock"
  # 2. Detailed objects with custom messages: { pattern: "*.lock", message: "..." }
  uneditableFiles:
    - ".conclaude.yml" # Protect conclaude config from AI modification
    - ".conclaude.yaml" # Alternative config extension
  # Additional examples:
  # uneditableFiles:
  #   # Simple patterns (backward compatible)
  #   - "./package.json"      # specific file
  #   - "*.md"                # file extension
  #   - "src/**/*.ts"         # nested patterns
  #   - "docs/**"             # entire directories
  #
  #   # Detailed patterns with custom error messages
  #   - pattern: "*.lock"
  #     message: "Lock files are automatically created. Run 'npm install' to update."
  #   - pattern: ".env*"
  #     message: "Environment files contain secrets. Use .env.example instead."
  #   - pattern: "{package,tsconfig}.json"
  #     message: "Configuration files require team review before changes."

  # Prevent Claude from creating or modifying files that are git-ignored
  # When enabled, files matching patterns in .gitignore will be protected
  # Uses your existing .gitignore as the source of truth for file protection
  preventUpdateGitIgnored: false

  # Tool usage validation rules - control which tools can be used on which files
  # Allows fine-grained control over tool usage based on file patterns
  toolUsageValidation: []
  # Examples:
  # toolUsageValidation:
  #   - tool: "Write"
  #     pattern: "**/*.js"
  #     action: "allow"
  #     message: "Writing to JavaScript files is allowed"
  #   - tool: "*"
  #     pattern: ".env*"
  #     action: "block"
  #     message: "Environment files cannot be modified"

  # Directories where file additions are prevented (in addition to root)
  # List of directory paths where new files cannot be created
  preventAdditions: []
  # Examples:
  # preventAdditions:
  #   - "dist"
  #   - "build"
  #   - "node_modules"

  # Prevent editing of files with generation markers (enabled by default)
  # Checks for common markers like "DO NOT EDIT", "Code generated by", etc.
  preventGeneratedFileEdits: true

  # Custom message when blocking file edits with generation markers
  # Available placeholders: {file_path}, {marker}
  generatedFileMessage: null
  # Example:
  # generatedFileMessage: "Cannot modify {file_path} - it contains '{marker}' marker"

# System notifications configuration
notifications:
  # Enable system notifications for hook execution
  enabled: false

  # List of hook names that should trigger notifications
  # Use ["*"] to receive notifications for all hooks
  # Common hook names: "Stop", "PreToolUse", "PostToolUse", "SessionStart", "UserPromptSubmit", "Notification", "SubagentStop", "PreCompact"
  hooks: []
  # Examples:
  # hooks: ["*"]                    # All hooks
  # hooks: ["Stop", "PreToolUse"]   # Only specific hooks
  # hooks: ["Stop"]                 # Only stop hook notifications

  # Show error notifications (hook failures, system errors)
  showErrors: false

  # Show success notifications (hook completion, successful operations)
  showSuccess: false

  # Show system event notifications (session start/end, configuration loaded)
  showSystemEvents: true
# Permission request hook configuration - controls tool permission decisions
# This hook is fired when Claude requests permission to use a tool
# Use this to automatically approve or deny tool usage based on rules
#
# permissionRequest:
#   # Default decision when a tool doesn't match any rule: "allow" or "deny"
#   # Recommended: "deny" for security (whitelist approach)
#   default: deny
#
#   # Tools to explicitly allow (supports glob patterns)
#   # These patterns are checked AFTER deny patterns
#   allow:
#     - "Read"       # Exact match - allows only "Read" tool
#     - "Glob"       # Exact match - allows only "Glob" tool
#     - "Grep"       # Exact match - allows file content search
#     - "Edit"       # Exact match - allows file editing
#     - "Write"      # Exact match - allows file writing
#     - "Task"       # Exact match - allows subagent tasks
#     - "Bash"       # Exact match - allows bash commands
#
#   # Tools to explicitly deny (supports glob patterns)
#   # Deny patterns take precedence over allow patterns
#   deny:
#     - "BashOutput"   # Block reading background process output
#     - "KillShell"    # Block terminating background shells
#
# Pattern examples:
#   - "Bash"      # Exact match - only "Bash"
#   - "*"         # Wildcard - matches any tool
#   - "Edit*"     # Prefix match - matches "Edit", "EditFile", etc.
#   - "*Read"     # Suffix match - matches "Read", "FileRead", etc.
#
# Common configurations:
#
# Whitelist approach (recommended for security):
# permissionRequest:
#   default: deny
#   allow:
#     - "Read"
#     - "Glob"
#     - "Grep"
#     - "Edit"
#
# Blacklist approach (more permissive):
# permissionRequest:
#   default: allow
#   deny:
#     - "BashOutput"
#     - "KillShell"
